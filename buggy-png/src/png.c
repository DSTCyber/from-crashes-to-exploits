/*
 * png.c
 *
 * Parse a PNG file. The API is heavily based off the libpng API.
 *
 * libpng version 1.2.5 - October 3, 2002
 * Copyright (c) 1998-2002 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 * 
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer and license in
 * the license file.
 *
 * Modifications by DST Group, 2018
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <zlib.h>

#include "png.h"

#define MAX_MSG_LEN 256

static void png_error(png_struct_t *png_ptr, const char *fmt, ...) {
  // Unused
  (void)png_ptr;

  char error_message[MAX_MSG_LEN];
  va_list args;

  va_start(args, fmt);
  vsnprintf(error_message, MAX_MSG_LEN, fmt, args);
  va_end(args);

  fprintf(stderr, "error: %s\n", error_message);

  // This is normally an abort
  exit(1);
}

static void png_warning(png_struct_t *png_ptr, const char *fmt, ...) {
  // Unused
  (void)png_ptr;

  char warning_message[MAX_MSG_LEN];
  va_list args;

  va_start(args, fmt);
  vsnprintf(warning_message, MAX_MSG_LEN, fmt, args);
  va_end(args);

  fprintf(stderr, "warning: %s\n", warning_message);
}

static void png_read_data(png_struct_t *png_ptr, png_byte *data,
                          size_t length) {
  size_t check = fread(data, 1, length, png_ptr->io_ptr);

  if (check != length) {
    png_error(png_ptr, "Read error. Expected length=%d, actual read=%d",
            length, check);
  }
}

static png_uint_32 png_get_uint_32(png_byte *buf) {
    return ((png_uint_32)(*buf) << 24) +
        ((png_uint_32)(*(buf + 1)) << 16) +
         ((png_uint_32)(*(buf + 2)) << 8) +
         (png_uint_32)(*(buf + 3));
}

static png_uint_16 png_get_uint_16(png_byte *buf) {
    return (png_uint_16)(((png_uint_16)(*buf) << 8) +
            (png_uint_16)(*(buf + 1)));
}

static int png_check_sig(png_byte *sig) {
  png_byte png_sig[8] = {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};

  return memcmp(sig, png_sig, 8);
}

static void png_init_io(png_struct_t *png_ptr, FILE *fp) {
  png_ptr->io_ptr = (void *)fp;
}

static void png_set_sig_bytes(png_struct_t *png_ptr, int num_bytes) {
  if (num_bytes > 8) {
    png_error(png_ptr, "Too many bytes for PNG signature: expected 8, got %d",
            num_bytes);
  }

  png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
}

static void png_calculate_crc(png_struct_t *png_ptr, png_byte *ptr,
                              size_t length) {
  // Assume that we calculate a CRC for all chunks
  png_ptr->crc = crc32(png_ptr->crc, ptr, length);
}

static void png_reset_crc(png_struct_t *png_ptr) {
  png_ptr->crc = crc32(0, Z_NULL, 0);
}

static void png_crc_read(png_struct_t *png_ptr, png_byte *buf, size_t length) {
  png_read_data(png_ptr, buf, length);
  png_calculate_crc(png_ptr, buf, length);
}

static int png_crc_error(png_struct_t *png_ptr) {
  png_byte crc_bytes[4];
  png_uint_32 crc;

  png_read_data(png_ptr, crc_bytes, 4);

  crc = png_get_uint_32(crc_bytes);
  return crc != png_ptr->crc;
}

static int png_crc_finish(png_struct_t *png_ptr, png_uint_32 skip) {
  size_t i;
  size_t istop = png_ptr->zbuf_size;

  for (i = skip; i > istop; i -= istop) {
    png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
  }

  if (i) {
    png_crc_read(png_ptr, png_ptr->zbuf, i);
  }

  if (png_crc_error(png_ptr)) {
    return 1;
  }

  return 0;
}

static void png_handle_IHDR(png_struct_t *png_ptr, png_uint_32 length) {
  png_byte buf[13];
  png_uint_32 width, height;
  int bit_depth, color_type, compression_type;
  int interlace_type;

  if (png_ptr->mode & PNG_HAVE_IHDR) {
    png_error(png_ptr, "Out of place IHDR");
  }

  if (length != 13) {
    png_error(png_ptr, "Invalid IHDR chunk");
  }

  png_ptr->mode |= PNG_HAVE_IHDR;

  png_crc_read(png_ptr, buf, 13);
  png_crc_finish(png_ptr, 0);

  width = png_get_uint_32(buf);
  height = png_get_uint_32(buf + 4);
  bit_depth = buf[8];
  color_type = buf[9];
  compression_type = buf[10];
  interlace_type = buf[12];

  png_ptr->width = width;
  png_ptr->height = height;
  png_ptr->bit_depth = bit_depth;
  png_ptr->interlaced = interlace_type;
  png_ptr->color_type = color_type;

  switch (png_ptr->color_type) {
  case PNG_COLOR_TYPE_GRAY:
  case PNG_COLOR_TYPE_PALETTE:
    png_ptr->channels = 1;
    break;
  case PNG_COLOR_TYPE_RGB:
    png_ptr->channels = 3;
    break;
  case PNG_COLOR_TYPE_GRAY_ALPHA:
    png_ptr->channels = 2;
    break;
  case PNG_COLOR_TYPE_RGB_ALPHA:
    png_ptr->channels = 4;
    break;
  }

  png_ptr->pixel_depth = (png_ptr->bit_depth * png_ptr->channels);
  png_ptr->rowbytes = ((png_ptr->width * png_ptr->pixel_depth + 7) >> 3);

  // At this point we would normally call png_set_IHDR
  (void)compression_type;
}

static void png_handle_IEND(png_struct_t *png_ptr, png_uint_32 length) {
  if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT)) {
    png_error(png_ptr, "No image in file");
  }

  png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);

  if (length != 0) {
    png_warning(png_ptr, "Incorrect IEND chunk length");
  }

  png_crc_finish(png_ptr, length);
}

static void png_handle_PLTE(png_struct_t *png_ptr, png_uint_32 length) {
  png_color palette[PNG_MAX_PALETTE_LENGTH];
  int num, i;

  if (!(png_ptr->mode & PNG_HAVE_IHDR)) {
    png_error(png_ptr, "Missing IHDR before PLTE");
  } else if (png_ptr->mode & PNG_HAVE_IDAT) {
    png_warning(png_ptr, "Invalid PLTE after IDAT");
    png_crc_finish(png_ptr, length);
    return;
  } else if (png_ptr->mode & PNG_HAVE_PLTE) {
    png_error(png_ptr, "Duplicate PLTE chunk");
  }

  png_ptr->mode |= PNG_HAVE_PLTE;

  if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) {
    png_warning(png_ptr, "Ignoring PLTE chunk in grayscale PNG");
    png_crc_finish(png_ptr, length);
    return;
  }

  if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE) {
    png_crc_finish(png_ptr, length);
    return;
  }

  if (length > 3 * PNG_MAX_PALETTE_LENGTH || length % 3) {
    if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE) {
      png_warning(png_ptr, "Invalid palette chunk");
      png_crc_finish(png_ptr, length);
      return;
    } else {
      png_error(png_ptr, "Invalid palette chunk");
    }
  }

  num = length / 3;

  for (i = 0; i < num; i++) {
    png_byte buf[3];

    png_crc_read(png_ptr, buf, 3);
    palette[i].red = buf[0];
    palette[i].green = buf[1];
    palette[i].blue = buf[2];
  }

  if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
    png_crc_finish(png_ptr, 0);
  } else if (png_crc_error(png_ptr)) {
    // Just treat it as an error
    png_error(png_ptr, "CRC error");
  }

  // At this point we would normally call png_set_PLTE
  (void)palette;
}

static void png_handle_tRNS(png_struct_t *png_ptr, png_uint_32 length) {
  png_byte readbuf[PNG_MAX_PALETTE_LENGTH];

  if (!(png_ptr->mode & PNG_HAVE_IHDR)) {
    png_error(png_ptr, "Missing IHDR before tRNS");
  } else if (png_ptr->mode & PNG_HAVE_IDAT) {
    png_warning(png_ptr, "Invalid tRNS after IDAT");
    png_crc_finish(png_ptr, length);
    return;
  } else if (png_ptr->valid & PNG_INFO_tRNS) {
    png_warning(png_ptr, "Duplicate tRNS chunk");
    png_crc_finish(png_ptr, length);
    return;
  }

  if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) {
    /*
     * This is the location of the bug that leads to CVE-2004-0597. If a PNG
     * file is of an incorrect format (i.e. if the PLTE is missing before the
     * tRNS chunk), then the length check is missed prior to calling
     * png_crc_read.
     *
     * The exact flaw would seem to be a logic error; failure to bail out of
     * the function after the warning condition is hit. If the first warning
     * condition is hit, then the length check is missed due to use of an "else
     * if".
     *
     * Reference: http://scary.beasts.org/security/CESA-2004-001.txt
     */
    if (!(png_ptr->mode & PNG_HAVE_PLTE)) {
      png_warning(png_ptr, "Missing PLTE before tRNS");
    } else if (length > png_ptr->num_palette) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
    }
    if (length == 0) {
      png_warning(png_ptr, "Zero length tRNS chunk");
      png_crc_finish(png_ptr, length);
      return;
    }

    /* The length check can be skipped, allowing readbuf to be overflowed. */
    png_crc_read(png_ptr, readbuf, length);
    png_ptr->num_trans = length;
  } else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB) {
    png_byte buf[6];

    if (length != 6) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
    }

    png_crc_read(png_ptr, buf, length);
    png_ptr->num_trans = 1;
    png_ptr->trans_values.red = png_get_uint_16(buf);
    png_ptr->trans_values.green = png_get_uint_16(buf + 2);
    png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
  } else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY) {
    png_byte buf[6];

    if (length != 2) {
      png_warning(png_ptr, "Incorrect tRNS chunk length");
      png_crc_finish(png_ptr, length);
      return;
    }

    png_crc_read(png_ptr, buf, 2);
    png_ptr->num_trans = 1;
    png_ptr->trans_values.gray = png_get_uint_16(buf);
  } else {
    png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
    png_crc_finish(png_ptr, length);
    return;
  }

  if (png_crc_finish(png_ptr, 0)) {
    return;
  }

  // At this point we would normally call png_set_tRNS
}

static void png_handle_unknown(png_struct_t *png_ptr, png_uint_32 length) {
  // Just warn
  png_warning(png_ptr, "Unknown chunk type: %c%c%c%c (length=%d)",
          png_ptr->chunk_name[0], png_ptr->chunk_name[1],
          png_ptr->chunk_name[2], png_ptr->chunk_name[3], length);
  png_crc_finish(png_ptr, length);
}

static void png_read_info(png_struct_t *png_ptr) {
  // Assume that the PNG signature has already been read

  for (;;) {
    PNG_IHDR;
    PNG_IDAT;
    PNG_IEND;
    PNG_PLTE;
    PNG_tRNS;

    png_byte chunk_length[4];
    png_uint_32 length;

    png_read_data(png_ptr, chunk_length, 4);
    length = png_get_uint_32(chunk_length);

    png_reset_crc(png_ptr);
    png_crc_read(png_ptr, png_ptr->chunk_name, 4);

    if (length > PNG_MAX_UINT) {
      png_error(png_ptr, "Invalid chunk length %d", length);
    }

    if (!memcmp(png_ptr->chunk_name, png_IHDR, 4)) {
      png_handle_IHDR(png_ptr, length);
    } else if (!memcmp(png_ptr->chunk_name, png_IEND, 4)) {
      png_handle_IEND(png_ptr, length);
    } else if (!memcmp(png_ptr->chunk_name, png_PLTE, 4)) {
      png_handle_PLTE(png_ptr, length);
    } else if (!memcmp(png_ptr->chunk_name, png_IDAT, 4)) {
      if (!(png_ptr->mode & PNG_HAVE_IHDR)) {
        png_error(png_ptr, "Missing IHDR before IDAT");
      } else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
                 !(png_ptr->mode & PNG_HAVE_PLTE)) {
        png_error(png_ptr, "Missing PLTE before IDAT");
      }

      png_ptr->idat_size = length;
      png_ptr->mode |= PNG_HAVE_IDAT;
      break;
    } else if (!memcmp(png_ptr->chunk_name, png_tRNS, 4)) {
      png_handle_tRNS(png_ptr, length);
    } else {
      png_handle_unknown(png_ptr, length);
    }
  }
}

/*
 * Publically exposed functions (from png.h).
 */

png_struct_t *png_read(FILE *infile) {
  png_byte sig[8];
  png_struct_t *png_ptr;

  fread(sig, 1, 8, infile);
  if (png_check_sig(sig)) {
    // Failed to match PNG signature
    fprintf(stderr, "error: incorrect PNG signature\n");
    return NULL;
  }

  png_ptr = (png_struct_t *)malloc(sizeof(png_struct_t));
  if (!png_ptr) {
    // Failed to allocate memory for PNG struct
    fprintf(stderr, "error: unable to allocate memory for png struct\n");
    return NULL;
  }

  // Initialize zbuf - compression buffer
  png_ptr->zbuf_size = PNG_ZBUF_SIZE;
  png_ptr->zbuf = (png_byte*)malloc(png_ptr->zbuf_size);
  if (!png_ptr->zbuf) {
      free(png_ptr);
      return NULL;
  }

  png_init_io(png_ptr, infile);
  png_set_sig_bytes(png_ptr, 8);
  png_read_info(png_ptr);

  return png_ptr;
}

void png_destroy(png_struct_t *png_ptr) {
  if (!png_ptr) {
    return;
  }

  free(png_ptr);
}
